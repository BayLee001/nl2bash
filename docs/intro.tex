%!TEX root=writeup.tex
\section{Introduction}

% What is the problem?
% Why is it important?
% What makes it hard?
% How will we solve it?

The command line interface (CLI) enables users to perform a rich set of actions including file system manipulation, remote control, system configuration, and more. CLI programming is considered an important software development skill; many companies expect CLI proficiency when hiring new software engineers. Besides, mastering command line operations greatly boost productivity in several other professions, such as research scientists, physicians and students. People in these industries typically have experimental results and other relevant information stored on hard disks, and have to repeatedly perform basic file operations to retrieve and to update those information. Most of these operations can be succinctly represented in a short command line.

Nevertheless, the rich vocabulary available to CLI users requires a high degree of memorization and familiarity, and as a result, new users often find it difficult to master. On the other hand, % many CLI tasks can be expressed succinctly in natural language
the users have clear ideas about their goals and can often express them succinctly in natural language~\cite{Myers:2004:NPL:1015864.1015888}. Thus, there is great value in convering natural language commands into CLI programs~\cite{Pederson-Report,Manaris:1994:DNL:198125.198137,ZOLTANFORD1991527}. The table below shows a few examples of natural language descriptions paired up with executable commands. The examples are gathered from StackOverflow\footnote{\url{https://stackoverflow.com}}, UnixExchange\footnote{\url{http://unix.stackexchange.com/questions/tagged/bash}} and other online resources.

\begin{center}
% \begin{table}[ht]
\begin{tabular}{p{3in}p{3in}}
    \textbf{Question} & \textbf{Answer} \\
    \hline \hline
    How to count all the lines of code in a directory recursively?%
        \footnote{\url{https://stackoverflow.com/questions/1358540/how-to-count-all-the-lines-of-code-in-a-directory-recursively}} &
        \texttt{find . -name '*.php' | xargs wc -l} \\
    \hline
    Copy folder recursively, excluding some folders%
        \footnote{\url{https://stackoverflow.com/questions/2193584/copy-folder-recursively-excluding-some-folders}} &
        \texttt{rsync -av --exclude='path1/to/exclude' --exclude='path2/to/exclude' source destination} \\
\end{tabular}
% \caption{Natural language description and command line pairs crawled from StackOverflow.}
% \end{table}
\end{center}

% Online forums such as StackOverflow\footnote{\url{https://stackoverflow.com}}, UnixExchange\footnote{\url{http://unix.stackexchange.com/questions/tagged/bash}} and BashOneLiner\footnote{\url{http://www.bashoneliners.com/oneliners/oneliner/popular/}} provide a large set of simple questions and proposed solutions. For example:

Given natural language descriptions of a task (such as those on the left), we desire system to translate these descriptions into executable commands (such as those on the right). Natural language programming techniques has have shown promise in several domains, including database queries~\cite{DBLP:journals/pvldb/LiJ14, DBLP:conf/sigmod/GulwaniM14}, text editing~\cite{DBLP:journals/corr/DesaiGHJKMRR15} and smart phone scripting~\cite{DBLP:conf/mobisys/LeGS13}. Two factors make this problem challenging:
\begin{itemize}
\item \textbf{Ambiguity.} Natural language descriptions are inherently ambiguous. Though several techniques including interactive disambiguation~\cite{DBLP:journals/pvldb/LiJ14} and keyword-based translation~\cite{DBLP:conf/sigmod/GulwaniM14} have been proposed, there are still no general techniques that can handle all inputs. Unfortunately, partial and ill-formed descriptions are common in command line questions. Even in the examples above, the askers have omitted many details such as the names of the folders to operate on.
\item \textbf{Richness in basic operations.} Unlike other domains like database queries, which are complex in their program structure but simple in atomic operations, command line programs are often simple in structure but complex in basic operations. The set of CLI commands is very large.
\end{itemize}
