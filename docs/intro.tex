%!TEX root=writeup.tex
\section{Introduction}

% What is the problem?
% Why is it important?
% What makes it hard?
% How will we solve it?

The command line interface (CLI) enables users to perform a rich set of actions including file system manipulation, remote control, system configuration, and more. CLI programming is considered an important software development skill; many companies expect CLI proficiency when hiring new software engineers.

The rich vocaulary avalable to CLI users requires a high degree of memorization and familiarity, and as a result, new users often find it difficult to master. However, many CLI tasks can be expressed succinctly in natural language. Thus, there is great value in convering natural language descriptions into CLI programs~\cite{Pederson-Report,Manaris:1994:DNL:198125.198137,ZOLTANFORD1991527}. Online forums such as StackOverflow\footnote{\url{https://stackoverflow.com}}, UnixExchange\footnote{\url{http://unix.stackexchange.com/questions/tagged/bash}} and BashOneLiner\footnote{\url{http://www.bashoneliners.com/oneliners/oneliner/popular/}} provide a large dataset of simple questions and proposed solutions. For example:

\begin{center}
\begin{tabular}{p{3in}p{3in}}
    \textbf{Question} & \textbf{Answer} \\
    \hline \hline
    How to count all the lines of code in a directory recursively?%
        \footnote{\url{https://stackoverflow.com/questions/1358540/how-to-count-all-the-lines-of-code-in-a-directory-recursively}} &
        \texttt{find . -name '*.php' | xargs wc -l} \\
    \hline
    Copy folder recursively, excluding some folders%
        \footnote{\url{https://stackoverflow.com/questions/2193584/copy-folder-recursively-excluding-some-folders}} &
        \texttt{rsync -av --exclude='path1/to/exclude' --exclude='path2/to/exclude' source destination} \\
\end{tabular}
\end{center}

Given natural language descriptions of a task (such as those on the left), we desire system to translate these descriptions into executable commands (such as those on the right). Natural language programming techniques has have seen success in several domains, including database queries~\cite{DBLP:journals/pvldb/LiJ14, DBLP:conf/sigmod/GulwaniM14}, text editing~\cite{DBLP:journals/corr/DesaiGHJKMRR15} and smart phone scripting~\cite{DBLP:conf/mobisys/LeGS13}. Two factors make this problem challenging:
\begin{itemize}
\item \textbf{Ambiguity.} Natural language descriptions are inherently ambiguous. Though several techniques including interactive disambiguation~\cite{DBLP:journals/pvldb/LiJ14} and keyword-based translation~\cite{DBLP:conf/sigmod/GulwaniM14} have been proposed, there are still no general techniques that can handle all inputs. Unfortunately, partial and ill-formed descriptions are common in command line questions. Even in the examples above, the askers have omitted many details such as the names of the folders to operate on.
\item \textbf{Richness in basic operations.} Unlike other domains like database queries, which are complex in their program structure but simple in atomic operations, command line programs are often simple in structure but complex in basic operations. The set of CLI commands is very large.
\end{itemize}

\todo{At a very high level, how will we address these challenges?}
