%!TEX root=writeup.tex
\section{Related Work}

% \paragraph{Domain-Specific Natural Language Programming} The problem of translating natural language into executable code have been studied since decades ago~\cite{Ballard:1979:PNL:800177.810072,Pederson-Report}. Most of previous research prototyped on domain-specific languages, ranging from the Structured Query Language (SQL)~\cite{Nihalani_NLIDB_review} to text-editing commands for Office suite applications~\cite{DBLP:journals/corr/DesaiGHJKMRR15}.

\paragraph{Programming by Natural Language} Programming by natural language (PBNL) is a technique to translate natural language descriptions to structured programs. Several PBNL systems exist to support database queries~\cite{DBLP:conf/sigmod/GulwaniM14, DBLP:journals/tods/LiYJ07, DBLP:journals/pvldb/LiJ14}, text editing~\cite{DBLP:journals/corr/DesaiGHJKMRR15}, API call synthesis~\cite{DBLP:journals/corr/RaghothamanWH15} and smartphone scripts synthesis~\cite{DBLP:conf/mobisys/LeGS13}.

NaLIR~\cite{DBLP:journals/pvldb/LiJ14} is a system designed to construct SQL queries from natural language. NaLIR operates by first parsing a natural language sentence into a parse tree and then converting the parse tree to a SQL query according to hand-coded rules. The system is able to resolve possible ambiguities by asking yes/no questions to users during the conversion. Since NaLIR requires a well-formed parse tree to infer the mapping, it depends on relatively high natural language qualities. Unlike NaLIR, our system learns the translation rules using training data and manpages. We will rely on users to fix any ambiguities on their own after the tool runs instead of by asking explicit questions during operation.

Desai et al.~\cite{DBLP:journals/corr/DesaiGHJKMRR15} provide a general framework PBNL systems and demonstrate its success in several domains including text-editing and QA system answering. This framework is generalized from NLyze~\cite{DBLP:conf/sigmod/GulwaniM14} and SmartSynth~\cite{DBLP:conf/mobisys/LeGS13} and provides a meta language to design PBNL systems for new domains. The framework requires a set of basic mapping rules as input. It first generates a set of program fragments based on the NL specification, and then enumerates all possible programs consisting of these fragments. A scoring scheme ranks the programs based on feature coverage and structural similarity. Command-line instructions do not fit neatly into this framework since they have simple structure but many basic expressions. Again, our system avoids manually constructing rewrite rules through machine learning. A benefit of this approach is that the range of possible outputs can be extended very easily---potentially on-the-fly based on what programs are available on the user's machine.

\paragraph{Programming by Demonstration} Instead of asking for natural language input, programming by demonstration (PBD) systems~\cite{DBLP:journals/ml/LauWDW03, DBLP:journals/cacm/GulwaniHS12, DBLP:conf/pldi/HarrisG11, DBLP:conf/popl/Gulwani11} ask the user to specify the task by providing input/output examples or demonstrating operation traces. However, since command-line operations may involve many different files they can be difficult to write examples for.

\paragraph{Keyword Programming} Keyword programming techniques synthesize programs (or program fragments) by heuristically searching a large software corpus for programs that are similar to the given keywords. Keyword programming has shown some success in specific tasks like API call generation~\cite{DBLP:journals/ase/LittleM09, DBLP:conf/pldi/MandelinXBK05} and database queries~\cite{DBLP:conf/icde/AgrawalCD02, DBLP:conf/icde/BhalotiaHNCS02}. However, since structural information is not exposed to the keywords, keyword programming has relatively low precision and often fails to recommend correct programs.

\paragraph{Semantic Parsing} 
% A number of natural language processing (NLP) research were conducted with a special focus on molding natural language into programming tools~\cite{mihalcea2006nlp,LandhauBer:2015:TUP:2820668.2820671}. Besides, 
%the task of synthesizing programs from natural language meets the 
Recently there is a surge of interest from the NLP community in learning to map natural language into formal meaning representations~\cite{Zettlemoyer05learningto,artzi2013weakly,DBLP:Poon13,Kwiatkowski:2011:LGC:2145432.2145593,liang2013learning}. The task was broadly named semantic parsing. In the natural language (NL)-based program synthesis scenario, semantic parsing naturally becomes a crucial intermediate step, in which it maps natural language commands into the formal specification that program synthesis relies on.  Recent advances in natural language processing have enabled the adoption of more sophisticated linguistic representation, such as the combinatory categorical grammar (CCG)~\cite{opac-b1080082}, as features for constructing the mapping. It also sheds light on more efficient parsing~\cite{lewis2015joint} and more effective machine learning algorithms~\cite{DBLP:journals/corr/ZarembaS14} which makes more efficient and precise NL-based program synthesis feasible.
% Compared to traditional syntactic parsing that maps natural language to its syntactic parse tree~\cite{Klein:2003:AUP:1075096.1075150}, semantic parsing. 
% Despite the development of linguistic-based semantic theory~\cite{dowty1989} and abstract meaning representation~\cite{Banarescu13abstractmeaning}, the majority of the semantic parsing frameworks were implanted in real-world applications
