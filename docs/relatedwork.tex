%!TEX root=writeup.tex
\section{Related Work}

% \paragraph{Domain-Specific Natural Language Programming} The problem of translating natural language into executable code have been studied since decades ago~\cite{Ballard:1979:PNL:800177.810072,Pederson-Report}. Most of previous research prototyped on domain-specific languages, ranging from the Structured Query Language (SQL)~\cite{Nihalani_NLIDB_review} to text-editing commands for Office suite applications~\cite{DBLP:journals/corr/DesaiGHJKMRR15}.

\paragraph{Programming by Natural Language} Programming by natural language (PBNL) is a technique to translate natural language descriptions to structured programs. Several PBNL systems exist to support database queries~\cite{DBLP:conf/sigmod/GulwaniM14, DBLP:journals/tods/LiYJ07, DBLP:journals/pvldb/LiJ14}, text editing~\cite{DBLP:journals/corr/DesaiGHJKMRR15}, API call synthesis~\cite{DBLP:journals/corr/RaghothamanWH15} and smartphone scripts synthesis~\cite{DBLP:conf/mobisys/LeGS13}.

NaLIR~\cite{DBLP:journals/pvldb/LiJ14} is a system designed to construct SQL queries from natural language. NaLIR operates by first parsing a natural language sentence into a parse tree and then converting the parse tree to a SQL query according to hand-coded rules. The system is able to resolve possible ambiguities by asking yes/no questions to users during the conversion. Since NaLIR requires a well-formed parse tree to infer the mapping, it depends on relatively high natural language qualities. Unlike NaLIR, our system learns the translation rules using training data and manpages. We will rely on users to fix any ambiguities on their own after the tool runs instead of by asking explicit questions during operation.

Desai et al.~\cite{DBLP:journals/corr/DesaiGHJKMRR15} provide a general framework PBNL systems and demonstrate its success in several domains including text-editing and QA system answering. This framework is generalized from NLyze~\cite{DBLP:conf/sigmod/GulwaniM14} and SmartSynth~\cite{DBLP:conf/mobisys/LeGS13} and provides a meta language to design PBNL systems for new domains. The framework requires a set of basic mapping rules as input. It first generates a set of program fragments based on the NL specification, and then enumerates all possible programs consisting of these fragments. A scoring scheme ranks the programs based on feature coverage and structural similarity. Command-line instructions do not fit neatly into this framework since they have simple structure but many basic expressions. Again, our system avoids manually constructing rewrite rules through machine learning. A benefit of this approach is that the range of possible outputs can be extended very easily---potentially on-the-fly based on what programs are available on the user's machine.

\paragraph{Programming by Demonstration} Instead of asking for natural language input, program by demonstration (PBD) systems~\cite{DBLP:journals/ml/LauWDW03, DBLP:journals/cacm/GulwaniHS12, DBLP:conf/pldi/HarrisG11, DBLP:conf/popl/Gulwani11} ask the user to specify the task by providing input/output examples or demonstrating operation traces. However, since command-line operations may involve many different files they can be difficult to write examples for.

\paragraph{Keyword Programming} Keyword programming techniques synthesize programs (or program fragments) by heuristically searching a large software corpus for programs that are similar to the given keywords. Keyword programming has shown some success in specific tasks like API call generation~\cite{DBLP:journals/ase/LittleM09, DBLP:conf/pldi/MandelinXBK05} and database queries~\cite{DBLP:conf/icde/AgrawalCD02, DBLP:conf/icde/BhalotiaHNCS02}. However, since structural information is not exposed to the keywords, keyword programming has relatively low precision and often fails to recommend correct programs.

\paragraph{Semantic Parsing} Semantic parsing maps natural language commands into formal specifications. These specifications can be used as input to other synthesis tools. There has been a great deal of recent interest in this field~\cite{mihalcea2006nlp,LandhauBer:2015:TUP:2820668.2820671,Zettlemoyer05learningto,artzi2013weakly,DBLP:Poon13,Kwiatkowski:2011:LGC:2145432.2145593,liang2013learning}. Recent advances in natural language processing have enabled the adoption of more sophisticated linguistic representation, such as the combinatory categorical grammar (CCG)~\cite{opac-b1080082}, as features for constructing the mapping. Other researchers have investigated parsing efficiency~\cite{lewis2015joint} and more effective machine learning algorithms~\cite{DBLP:journals/corr/ZarembaS14}. We believe that simpler techniques based on simple machine learning can outperform these advanced strategies in the case of command-line programs given the large body of available training data.
