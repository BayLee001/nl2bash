%!TEX root=writeup.tex
\section{Related Work}

% \paragraph{Domain-Specific Natural Language Programming} The problem of translating natural language into executable code have been studied since decades ago~\cite{Ballard:1979:PNL:800177.810072,Pederson-Report}. Most of previous research prototyped on domain-specific languages, ranging from the Structured Query Language (SQL)~\cite{Nihalani_NLIDB_review} to text-editing commands for Office suite applications~\cite{DBLP:journals/corr/DesaiGHJKMRR15}.

\paragraph{Programming by Natural Language} Program by natural language (PBNL) is a technique to translate natural language descriptions to structured programs. Several PBNL systems are designed to support database query~\cite{DBLP:conf/sigmod/GulwaniM14, DBLP:journals/tods/LiYJ07, DBLP:journals/pvldb/LiJ14}, text editing~\cite{DBLP:journals/corr/DesaiGHJKMRR15}, API call synthesis~\cite{DBLP:journals/corr/RaghothamanWH15} and smartphone scripts synthesis~\cite{DBLP:conf/mobisys/LeGS13}.

Concretely, NaLIR~\cite{DBLP:journals/pvldb/LiJ14} is a system designed to support database query by translating natural language queries into SQL queries. NaLIR will first parse a natural language sentence to parse tree, and then infer a mapping from parse tree to a query tree by rules. When the query tree is generated, a deterministic translation algorithm will directly translate it to a SQL query. Besides, the system is able to resolve possible ambiguities by asking yes/no questions to users during the mapping inference stage to achieve relatively precision. However, as NaLIR requires a well-formed parse tree to infer the mapping, it requires relatively high natural language qualities. Besides, the ambiguous resolving procedure can only resolve ambiguity between system define concepts but not able to resolve undefined concepts. Based on machine learning techniques, our system is able to handle more noisy natural language inputs.

Desai et al.~\cite{DBLP:journals/corr/DesaiGHJKMRR15} provides a general framework for PBNL system design and shows it successful in several domains including text-editing and QA system answering. This framework is generalized from NLyze~\cite{DBLP:conf/sigmod/GulwaniM14} and SmartSynth~\cite{DBLP:conf/mobisys/LeGS13} and provides a meta language to design PBNL system for new domains. The framework will first generate a set of program fragments based on the NL specification, and then enumerate all possible programs consists of these fragments. When the set of programs is obtained, a scoring scheme is used to ranking the programs based on feature coverage and structural similarity. With this general framework, a designer is able to easily create PBNL system by providing the language specification and a set of basic mapping rules. However, unlike other domains, command-line instructions are simple in program structure but rich in basic expressions (which can be extend by developers), and this leads to the challenge to provide a fixed language specification to the framework to build the system. Differently in our system, we allow users to provide new corpus to extend the language feature using concept learning algorithms, and as a result, our technique addresses the command-line instruction synthesis problem better comparing to existing PBNL systems.

\paragraph{Programming by Demonstration} Instead of asking for natural language input, program by demonstration (PBD) systems~\cite{DBLP:journals/ml/LauWDW03, DBLP:journals/cacm/GulwaniHS12, DBLP:conf/pldi/HarrisG11, DBLP:conf/popl/Gulwani11} ask the user to specify the task by providing input/output examples or demonstrating operation traces. However, as many tasks achieve by command lines instructions are hard to sample and often involve operations on a large set of files and directories, demonstrations are examples are hard to hand-code, and as a result, natural language specifications achieve a better result in this domain.

\paragraph{Keyword Programming} Keyword programming refers to the technique to synthesize programs (or program fragments) by heuristically searching programs that are similar to the given keywords. Keyword programming shows some success in certain tasks like API call generation~\cite{DBLP:journals/ase/LittleM09, DBLP:conf/pldi/MandelinXBK05} and database queries~\cite{DBLP:conf/icde/AgrawalCD02, DBLP:conf/icde/BhalotiaHNCS02}. However, mainly due to the fact that program structural information is not exposed to the keywords, keyword programming has relatively low precision and often fail to recommend correct programs.

\paragraph{Parsing Natural Language to Logical Forms} A number of natural language processing (NLP) research were conducted with a special focus on molding natural language into programming tools~\cite{mihalcea2006nlp,LandhauBer:2015:TUP:2820668.2820671}. Besides, 
%the task of synthesizing programs from natural language meets the 
there is a surge of interest from the NLP community in mapping natural language into formal meaning representations~\cite{Zettlemoyer05learningto,artzi2013weakly,DBLP:Poon13,Kwiatkowski:2011:LGC:2145432.2145593,liang2013learning}. The task was broadly named semantic parsing. In the natural language (NL)-based program synthesis scenario, semantic parsing naturally becomes a crucial intermediate step, in which it maps natural language commands into the formal specification that program synthesis relies on.  Recent advances in natural language processing have enabled the adoption of more sophisticated linguistic representation, such as the combinatory categorical grammar (CCG)~\cite{opac-b1080082}, as features for constructing the mapping. It also sheds light on more efficient parsing~\cite{lewis2015joint} and more effective machine learning algorithms~\cite{DBLP:journals/corr/ZarembaS14} which makes more efficient and precise NL-based program synthesis feasible.
% Compared to traditional syntactic parsing that maps natural language to its syntactic parse tree~\cite{Klein:2003:AUP:1075096.1075150}, semantic parsing. 
% Despite the development of linguistic-based semantic theory~\cite{dowty1989} and abstract meaning representation~\cite{Banarescu13abstractmeaning}, the majority of the semantic parsing frameworks were implanted in real-world applications
