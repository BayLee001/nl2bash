\subsection{Language Design}
\label{subsec:represent}
An ideal intermediate language for the CLI programs should be expressive enough so that it covers many interesting real world cases, and concise enough for the synthesizer to efficiently synthesize. \autoref{fig:lang} presents the syntax of the intermediate language.

\begin{figure}[ht]
\[
\begin{array}{rlll}
\multicolumn{3}{l}{\textbf{Program}}\\
\mathit{p} & :=  & \mathit{cmd}~\overline{\mathit{option}} & \textrm{(Program)}\\
    &  & \mathit{p} ~\|~ \mathsf{xargs} ~\mathit{p} & \textrm{(Pipelined programs)} \\
\mathit{option} & := & \mathit{flag} & \textrm{(Command flag)}\\
                &    & \mathit{val} & \textrm{(Value)}\\
\mathit{cmd} & := & ... & \textrm{(Command names)}\\
\mathit{flag} & := & ... & \textrm{(Flag names)}\\
\mathit{val} & := & ...  & \textrm{(Primitive values)}\\
~\\
\multicolumn{3}{l}{\textbf{Command Signature}}\\
\mathit{sig} & := & \mathit{name}~\mathit{op} & \textrm{(Command signature)}\\
\mathit{op} &:= & \mathit{flag} & \textrm{(Flag)}\\
                &   & \mathit{arg}[\tau] & \textrm{(Argument)}\\
                &   & \mathit{arg}[\tau] ...& \textrm{(Argument list)}\\
                &   & \mathit{op}~|~\mathit{op} & \textrm{(Exclusive options)}\\
                &   & [ \mathit{op} ] & \textrm{(Optional options)}\\
~\\
\multicolumn{3}{l}{\textbf{Rules}}\\
\mathit{rule}^{*} &:=& \mathit{cmd}~\overline{\mathit{option}} : \tau & \textrm{(Command typing rule)}\\
~\\
\multicolumn{3}{l}{\textbf{Types}}\\
\tau_0 & := & \mathsf{void} ~|~ \mathsf{File} ~|~ \mathsf{Date} ~|~ ...& \textrm{(Primitive types)}\\
\tau & := & \tau_0 ~|~ (\bar{\tau}_0)\rightarrow \tau_0 & \textrm{(Type)}
\end{array}
\]
\caption{Intermediate Language syntax, where $\mathit{cmd}$ ranges over strings presernting command names, $\mathit{flag}$ are strings presenting flag names, $\mathit{val}$ presents values in bash programs, and $\mathit{arg}$ represents meta-argument names.}
\label{fig:lang}
\end{figure}


\textbf{Program} defines the formation rules for a program: i.e. a CLI program is either a primitive command or the pipeline of two programs. However, not all of programs that can be represented by the syntax is valid, e.g. the program \code{find -goal} is well formed under the syntax, but it is not a valid real CLI program, as the \code{goal} flag is not part of the command \code{find}. Thus, command signature is introduced to check the well-formedness of a given CLI program. 

The command signature defines the usage of a certain command: a CLI program is well formed only if it follows its corresponding structure. Besides, types help restrict usage of values in a program as other typed languages. Figure~\ref{fig:cmdsig} shows the signature of some commands used in our system. With this signature, a CLI program \code{mv -f -v a.txt b.txt} is will formed as it is captured by the signature of \code{mv}.

\begin{figure}[ht]
\[
\begin{array}{l}

\code{mv [-f | -i | -n] [-v] source:File target:File}\\
\code{mv [-f | -i | -n] [-v] source:File ... directory:File}\\
\code{sort [-bdfgiMnrckmosStTuz] [file:File ...]}\\
\code{grep [-abcdDEFGHhIiJLlmnOopqRSsUVvwxZ] [-A num:Number]} (... rest~omitted)\\
\code{cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source\_file:File target\_file:File}\\
\code{cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source\_file:File ... target\_directory:File}\\
\code{ls [-ABCFGHLOPRSTUW\@abcdefghiklmnopqrstuwx1] [file:File ...]}\\
...
\end{array}
\]
\vspace{-15pt}
\caption{Examples of some command signatures.}
\label{fig:cmdsig}
\end{figure}

Since the number of basic Linux commands and options is large even in domain-specific scenarios, it is difficult for a human designer to hand-code all of the generation rules. Though in the course project submission, we create the command signatures by hand, we plan as a longer-term project to semi-automate this step by adding information extracted from the Linux man pages\footnote{\url{http://linux.die.net/man/}}. With this support, extending our tool to handle new commands simply requires adding a new man page to the training data.