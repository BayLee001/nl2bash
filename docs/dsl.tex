%!TEX root=writeup.tex
\subsection{Language Design}
\label{subsec:represent}

Since different bash commands are designed by different developers, the synthax for bash commands is not informative enough for synthesis (as it does not provide enough constraints on which commands are well formed), it is necessary to provide a more strict language design for bash commands which reflects more syntactical constraints to ease the translation task.

\begin{figure}[ht]
\[
\mathit{bash} := \mathit{word}~(~\mathit{word}~)^{*}
\]
\vspace{-20pt}
\caption{Original bash syntax}
\end{figure}

The key design tradeoff for the language is the level of declarativity. The more declarative the langauge is, it is easier to perform translation, e.g. if \code{max} is provided as a primitive of the language, it is possible to direct translate descriptions with notion of maxinum into a command using the primitive \code{max}, on the other hand, if it is not provided, the command should be achieved using \code{sort} following by \code{first} to acheive the same goal, which is less straightforward compared to the first case. However, when the language is too declarative, collecting training data are harder, as it is harder to transform real bash commands in the dataset to its intermediate representation. In our design, we choose the latter case, to make the language designed to be closer to the original bash commands, so that we can directly parse a bash command into its intermediate representation, which provides us a larger set of traning data. \autoref{fig:lang} presents the syntax of the intermediate language.

\begin{figure}[ht]
\[
\begin{array}{rlll}
\multicolumn{3}{l}{\textbf{Program}}\\
\mathit{p} & :=  & \mathit{cmd}~\overline{\mathit{option}} & \textrm{(Program)}\\
    &  & \mathit{p} ~|~ \mathit{p} & \textrm{(Pipelined programs)} \\
\mathit{option} & := & \mathit{flag} & \textrm{(Command flag)}\\
                &    & \mathit{val} & \textrm{(Value)}\\
\mathit{cmd} & := & ... & \textrm{(Command names)}\\
\mathit{flag} & := & ... & \textrm{(Flag names)}\\
\mathit{val} & := & ...  & \textrm{(Primitive values)}\\
~\\
\multicolumn{3}{l}{\textbf{Command Signature}}\\
\mathit{sig} & := & \mathit{name}~\mathit{op} & \textrm{(Command signature)}\\
\mathit{op} &:= & \mathit{flag} & \textrm{(Flag)}\\
                &   & \mathit{arg}:\tau & \textrm{(Argument)}\\
                &   & \mathit{arg}:\tau~...& \textrm{(Argument list)}\\
                &   & \mathit{op}~\mathit{op} & \textrm{(Sequential options)}\\
                &   & \mathit{op}~|~\mathit{op} & \textrm{(Exclusive options)}\\
                &   & [ \mathit{op} ] & \textrm{(Optional options)}\\
~\\
\multicolumn{3}{l}{\textbf{Rules}}\\
\mathit{rule}^{*} &:=& \mathit{cmd}~\overline{\mathit{option}} : \tau & \textrm{(Command typing rule)}\\
~\\
\multicolumn{3}{l}{\textbf{Types}}\\
\tau_0 & := & \mathsf{void},~ \mathsf{File},~ \mathsf{Date},~\mathsf{Perm} ...& \textrm{(Primitive types)}\\
\tau & := & \tau_0 ~|~ (\bar{\tau}_0)\rightarrow \tau_0 & \textrm{(Type)}
\end{array}
\]
\caption{Intermediate Language syntax, where $\mathit{cmd}$ ranges over strings presernting command names, $\mathit{flag}$ are strings presenting flag names, $\mathit{val}$ presents values in bash programs, and $\mathit{arg}$ represents meta-argument names.}
\label{fig:lang}
\end{figure}


In the intermediate language, \textit{Program} defines the formation rules for a command: i.e. a command is either a primitive command or the pipeline of two programs. However, not all of programs that can be represented by the syntax is valid, e.g. the program \code{find -goal} is well formed under the syntax, but it is not a valid real CLI program, as the \code{goal} flag is not part of the command \code{find}. Thus, \textit{command signatures} are introduced to check the well-formedness of a given bash command.

\textit{Command signature} in \autoref{fig:lang} defines the usages for certain commands: a command is well formed only if it follows its corresponding structure. \textit{types} reflect the type of an argument, helping restrict usage of values in a command as types used in other typed languages. Figure~\ref{fig:cmdsig} shows the signature of some commands used in our system. With this signature, the command \code{mv -f -v a.txt b.txt} is will formed as it is captured by the signature of \code{mv}.

\begin{figure}[ht]
\[
\begin{array}{l}

\code{mv [-f | -i | -n] [-v] source:File target:File}\\
\code{mv [-f | -i | -n] [-v] source:File ... directory:File}\\
\code{sort [-bdfgiMnrckmosStTuz] [file:File ...]}\\
\code{grep [-abcdDEFGHhIiJLlmnOopqRSsUVvwxZ] [-A num:Number]} (... rest~omitted)\\
\code{cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source\_file:File target\_file:File}\\
\code{cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source\_file:File ... target\_directory:File}\\
\code{ls [-ABCFGHLOPRSTUW\@abcdefghiklmnopqrstuwx1] [file:File ...]}\\
...
\end{array}
\]
\vspace{-15pt}
\caption{Examples of some command signatures.}
\label{fig:cmdsig}
\end{figure}

Since the number of basic Linux commands and options is large even in domain-specific scenarios, it is difficult for a human designer to hand-code all of the generation rules. Though in the course project submission, we create the command signatures by hand, we plan as a longer-term project to semi-automate this step by adding information extracted from the Linux man pages\footnote{\url{http://linux.die.net/man/}}. With this support, extending our tool to handle new commands simply requires adding a new man page to the training data.