#!/usr/bin/env python
# -*- coding: UTF-8 -*-

"""
This file augments the AST generated by bashlex with single-command structure.
It also performs some normalization on the command arguments.
"""

from __future__ import print_function
import copy
import os
import re
import sys
sys.path.append(os.path.join(os.path.dirname(__file__), "..", "grammar"))

# bashlex stuff
import bast, errors, tokenizer, bparser
from lookup import ManPageLookUp
from nast import *

_NUM = b"_NUM"
_LONG_PATTERN = b"_LONG_PATTERN"
_PARAMETER = b"_PARAMETER"
_REGEX = b"_REGEX"
_H_NO_EXPAND = b"<H_NO_EXPAND>"
_V_NO_EXPAND = b"<V_NO_EXPAND>"

_DIGIT_RE = re.compile(br"\d+")

man_lookup = ManPageLookUp([os.path.join(
    os.path.dirname(__file__), "..", "grammar", "primitive_cmds_grammar.json")])

def cmd_arg_type_check(word, arg_status):
    arg_types = []
    for i in xrange(len(arg_status["non-optional"])):
        arg_type, is_list, filled = arg_status["non-optional"][i]
        if not is_list and filled:
            continue
        arg_types.append(arg_type)
    for i in xrange(len(arg_status["optional"])):
        arg_type, is_list, filled = arg_status["optional"][i]
        if not is_list and filled:
            continue
        arg_types.append(arg_type)

    assert(len(arg_types) > 0)
    arg_type = type_check(word, arg_types)

    for i in xrange(len(arg_status["non-optional"])):
        if arg_status["non-optional"][i][0] == arg_type:
            arg_status["non-optional"][i][2] = True
    for i in xrange(len(arg_status["optional"])):
        if arg_status["optional"][i][0] == arg_type:
            arg_status["optional"][i][2] = True

    return arg_type

def type_check(word, possible_types):
    """Heuristically determine argument types."""
    if word in ["+", ";", "{}"]:
        return "ReservedWord"
    if word.isdigit() and "Number" in possible_types:
        return "Number"
    if any(c.isdigit() for c in word):
        if word[-1] in ["k", "M", "G", "T", "P"] and "Size" in possible_types:
            return "Size"
        if word[-1] in ["s", "m", "h", "d", "w"] and "Time" in possible_types:
            return "Time"
    if "Permission" in possible_types:
        if any(c.isdigit() for c in word) or '=' in word:
            return "Permission"
    return possible_types[0]

def is_unary_logic_op(node, parent):
    if node.word == "!":
        return parent and parent.is_command("find")
    return node.word in right_associate_unary_logic_operators \
           or node.word in left_associate_unary_logic_operators

def is_binary_logic_op(node, parent):
    if node.word == '-o':
        if parent and parent.is_command("find"):
            node.word = "-or"
            return True
        else:
            return False
    if node.word == '-a':
        if parent and parent.is_command("find"):
            node.word = "-and"
            return True
        else:
            return False
    if node.word == ',':
        if parent and parent.is_command("find"):
            node.word = "-and"
            return True
        else:
            return False
    return node.word in binary_logic_operators

def special_command_normalization(cmd):
    # special normalization for certain commands
    ## remove all "sudo"'s
    cmd = cmd.replace("sudo", "")

    ## normalize utilities called with full path
    cmd = cmd.replace("/usr/bin/find", "find")
    cmd = cmd.replace("/bin/find", "find")
    cmd = cmd.replace("/usr/bin/grep", "grep")
    cmd = cmd.replace("/bin/rm", "rm")
    cmd = cmd.replace("/bin/mv", "mv")
    
    ## correct common typos
    cmd = cmd.replace("'{}'", "{}")
    cmd = cmd.replace("\"{}\"", "{}")
    cmd = cmd.replace("-i{}", "-I {}")
    cmd = cmd.replace("-I{}", "-I {}")
    cmd = cmd.replace(" [] ", " {} ")
    cmd = cmd.replace("-L.", "-L")
    cmd = cmd.replace("-mitime", "-mtime")
    cmd = cmd.replace("-dev", "-xdev")
    cmd = cmd.replace("-regex-type", "-regextype")
    cmd = cmd.replace("-\\(", "\\(")
    cmd = cmd.replace("-\\)", "\\)")
    cmd = cmd.replace("\"\\)", " \\)")
    cmd = cmd.replace("-\\!", "!")
    try:
        cmd = cmd.replace("— ", "-")
        cmd = cmd.replace("—", "-")
        cmd = cmd.replace("“", '"')
        cmd = cmd.replace("”", '"')
        cmd = cmd.replace("-\xd0\xbe", "-o")
        cmd = cmd.replace("\xe2\x80\x93 ", "-")
        cmd = cmd.replace('‘', '\'')
        cmd = cmd.replace('’', '\'')
    except UnicodeDecodeError, e:
        cmd = cmd.replace("— ".decode('utf-8'), "-")
        cmd = cmd.replace("—".decode('utf-8'), "-")
        cmd = cmd.replace("“".decode('utf-8'), '"')
        cmd = cmd.replace("”".decode('utf-8'), '"')
        cmd = cmd.replace("\xd0\xbe".decode('utf-8'), "o")
        cmd = cmd.replace("\xe2\x80\x93 ".decode('utf-8') , "-")
        cmd = cmd.replace('‘'.decode('utf-8'), '\'')
        cmd = cmd.replace('’'.decode('utf-8'), '\'')

    # more typo fixes
    cmd = re.sub("-prin($| )", '-print', cmd)
    cmd = cmd.replace("/bin/echo", "echo")
    cmd = cmd.replace(" exec sed ", " -exec sed ")
    cmd = cmd.replace(" xargs -iname ", " xargs ")
    cmd = cmd.replace(" -chour +1 ", " -cmin 60 ")

    ## remove shell character
    if cmd.startswith("\$ "):
        cmd = re.sub("^\$ ", '', cmd)
    if cmd.startswith("\# "):
        cmd = re.sub("^\# ", '', cmd)
    if cmd.startswith("\$find "):
        cmd = re.sub("^\$find ", "find ", cmd)
    if cmd.startswith("\#find "):
        cmd = re.sub("^\#find ", "find ", cmd)

    ## the first argument of "tar" is always interpreted as an option
    tar_fix = re.compile(' tar \w')
    if cmd.startswith('tar'):
        cmd = ' ' + cmd
    for w in re.findall(tar_fix, cmd):
        cmd = cmd.replace(w, w.replace(' tar ', ' tar -'))
    cmd = cmd.strip()
    return cmd

def attach_to_tree(node, parent):
    node.parent = parent
    node.lsb = parent.get_right_child()
    parent.add_child(node)
    if node.lsb:
        node.lsb.rsb = node

def detach_from_tree(node, parent):
    if not parent:
        return
    parent.remove_child(node)
    node.parent = None
    if node.lsb:
        node.lsb.rsb = node.rsb
    if node.rsb:
        node.rsb.lsb = node.lsb
    node.rsb = None
    node.lsb = None

def normalize_pattern(value, verbose=False):
    if value.isalpha() and value.isupper():
        return _REGEX
    value = value.replace("$HOME", "${HOME}")
    value = value.replace("~", "${HOME}")
    remove_current_dir = re.compile("\./")
    remove_dir_suffix = re.compile("/$")
    if not value == "/":
        value = re.sub(remove_dir_suffix, "", value)
    value = re.sub(remove_current_dir, "", value)
    if not (value.startswith("-")
            or value == "\"/\""
            or value == "/"
            or value == "\"normal/regular\""
            or value == "\"regular/normal\""
            or value == "\"files/directories\""
            or value == "\".\""
            or value == "."
            or value == "${HOME}"):
        if "$" in value:
            return _PARAMETER
        if (value[0] in ['\'', '"']
            and value[-1] in ['\'', '"']) \
                or ' ' in value \
                or '\\' in value \
                or '~' in value \
                or '*' in value \
                or '@' in value \
                or "%" in value \
                or '#' in value \
                or '?' in value:
            return _REGEX
        if '/' in value:
            if not (('u-' in value and len(value) <= 12) or
                    ('g-' in value and len(value) <= 12) or
                    ('o-' in value and len(value) <= 12) or
                    value[1:].isdigit() or
                    '+' in value or
                    '=' in value):
                return _REGEX
    for i, c in enumerate(value):
        if c == ".":
            if i == 0 or i == len(value)-1 \
                or not value[i-1].isdigit() \
                or not value[i+1].isdigit():
                return _REGEX

    return value

def normalize_ast(cmd, normalize_digits=True, normalize_long_pattern=True,
                  recover_quotation=True, verbose=False):
    """
    Convert the bashlex parse tree of a command into the normalized form.
    :param cmd: bash command to parse
    :param normalize_digits: replace all digits in the tree with the special
                             _NUM symbol
    :param recover_quotation: if set, retain quotation marks in the command
    :param verbose: if set, print error message.
    :return normalized_tree
    """
    cmd = cmd.replace('\n', ' ').strip()
    cmd = special_command_normalization(cmd)

    if not cmd:
        return None

    def normalize_word(node, recover_quote):
        w = recover_quotation(node) if recover_quote else node.word
        return w

    def recover_quotation(node):
        if with_quotation(node):
            return cmd[node.pos[0] : node.pos[1]]
        else:
            return node.word

    def with_quotation(node):
        return cmd[node.pos[0]] in ['"', '\''] \
               or cmd[node.pos[1]-1] in ['"', '\'']

    def normalize_argument(node, current, arg_type):
        value = normalize_word(node, recover_quotation)
        if normalize_long_pattern:
            value = normalize_pattern(value, verbose=verbose)
        if normalize_digits and arg_type != "Permission":
            value = re.sub(_DIGIT_RE, _NUM, value)
        if value in ["+", ";", "{}"]:
            arg_type = "ReservedWord"
        norm_node = ArgumentNode(value=value, arg_type=arg_type)
        attach_to_tree(norm_node, current)
        return norm_node

    def normalize_flag(node, current):
        value = normalize_word(node, recover_quotation)
        norm_node = FlagNode(value=value)
        attach_to_tree(norm_node, current)
        return norm_node

    def normalize_headcommand(node, current):
        value = normalize_word(node, recover_quotation)
        norm_node = HeadCommandNode(value=value)
        attach_to_tree(norm_node, current)
        return norm_node

    def normalize_command(node, current):
        arg_status = None                       # determine argument types
        head_commands = []
        unary_logic_ops = []
        binary_logic_ops = []
        unprocessed_unary_logic_ops = []
        unprocessed_binary_logic_ops = []

        def expecting(a_t):
            for arg_type, is_list, filled in arg_status["non-optional"]:
                if not is_list and filled:
                    continue
                if arg_type == a_t:
                    return True
            for arg_type, is_list, filled in arg_status["optional"]:
                if not is_list and filled:
                    continue
                if arg_type == a_t:
                    return True
            return False

        def organize_buffer(lparenth, rparenth):
            node = lparenth.rsb
            while node != rparenth:
                if node.kind == "unarylogicop":
                    adjust_unary_operators(node)
                node = node.rsb
            node = lparenth.rsb
            while node != rparenth:
                if node.kind == "binarylogicop":
                    adjust_binary_operators(node)
                node = node.rsb
            node = lparenth.rsb
            if node.rsb == rparenth:
                return lparenth.rsb
            else:
                norm_node = BinaryLogicOpNode(value="-and")
                while node != rparenth:
                    attach_to_tree(node, norm_node)
                    node = node.rsb
                return norm_node

        def adjust_unary_operators(node):
            if node.associate == UnaryLogicOpNode.RIGHT:
                # change right sibling to child
                rsb = node.rsb
                if not rsb:
                    print("Warning: unary logic operator without a right "
                          "sibling.")
                    print(node.parent)
                    return
                if rsb.value == "(":
                    unprocessed_unary_logic_ops.append(node)
                    return
                if rsb.value == ")":
                    # TODO: this corner case is not handled very well
                    node.associate = UnaryLogicOpNode.LEFT
                    unprocessed_unary_logic_ops.append(node)
                    return
                make_sibling(node, rsb.rsb)
                node.parent.remove_child(rsb)
                rsb.lsb = None
                rsb.rsb = None
                node.add_child(rsb)
            elif node.associate == UnaryLogicOpNode.LEFT:
                # change left sibling to child
                lsb = node.lsb
                if not lsb:
                    print("Warning: unary logic operator without a left "
                          "sibling.")
                    print(node.parent)
                    return
                if lsb.value == ")":
                    unprocessed_unary_logic_ops.append(node)
                    return
                if (lsb.kind == "binarylogicop" and lsb.get_num_of_children() < 2) \
                        or lsb.value == "(":
                    # TODO: this corner case is not handled very well
                    # it is often triggered by the bizarreness of -prune
                    return
                make_sibling(lsb.lsb, node)
                node.parent.remove_child(lsb)
                lsb.lsb = None
                lsb.rsb = None
                node.add_child(lsb)
            else:
                raise AttributeError("Cannot decide unary operator "
                                     "assocation: {}".format(node.symbok))

            # resolve single child of binary operators left as the result of
            # parentheses processing
            if node.parent.kind == "binarylogicop" \
                    and node.parent.value == "-and":
                if node.parent.get_num_of_children() == 1:
                    node.grandparent.replace_child(node.parent, node)

        def adjust_binary_operators(node):
            # change right sibling to Child
            # change left sibling to child
            rsb = node.rsb
            lsb = node.lsb

            if not rsb or not lsb:
                raise AttributeError("Error: binary logic operator must have "
                                     "both left and right siblings.")

            if rsb.value == "(" or lsb.value == ")":
                unprocessed_binary_logic_ops.append(node)
                # sibling is parenthese
                return

            assert(rsb.value != ")")
            assert(lsb.value != "(")

            make_sibling(node, rsb.rsb)
            make_sibling(lsb.lsb, node)
            node.parent.remove_child(rsb)
            node.parent.remove_child(lsb)
            rsb.rsb = None
            lsb.lsb = None

            if lsb.kind == "binarylogicop" and lsb.value == node.value:
                for lsbc in lsb.children:
                    make_parent_child(node, lsbc)
                make_parent_child(node, rsb)
                lsbcr = lsb.get_right_child()
                make_sibling(lsbcr, rsb)
            else:
                make_parent_child(node, lsb)
                make_parent_child(node, rsb)
                make_sibling(lsb, rsb)

            # resolve single child of binary operators left as the result of
            # parentheses processing
            if node.parent.kind == "binarylogicop" \
                    and node.parent.value == "-and":
                if node.parent.get_num_of_children() == 1:
                    node.grandparent.replace_child(node.parent, node)

        def attach_flag(node, attach_point_info):
            attach_point = attach_point_info[0]

            if node.word.startswith("--") \
                or is_unary_logic_op(node, attach_point) \
                or node.word in binary_logic_operators \
                or attach_point.value == "find" \
                or len(node.word) <= 1:
                normalize_flag(node, attach_point)
            else:
                # split flags
                assert(node.word.startswith('-'))
                options = node.word[1:]
                if len(options) == 1 and not options.isdigit():
                    normalize_flag(node, attach_point)
                else:
                    if options[-1].isdigit() and \
                        ((attach_point.value == "grep" and options.startswith("A")) or
                         (attach_point.value == "grep" and options.startswith("B")) or
                         (attach_point.value == "grep" and options.startswith("C")) or
                         (attach_point.value == "head" and options.isdigit()) or
                         (attach_point.value == "tail" and options.isdigit()) or
                         (attach_point.value == "head" and options.startswith("n")) or
                         (attach_point.value == "tail" and options.startswith("n")) or
                         (attach_point.value == "xargs" and options.startswith("l")) or
                         (attach_point.value == "xargs" and options.startswith("P"))):
                        node.word = re.sub(_DIGIT_RE, _NUM, node.word)
                        normalize_flag(node, attach_point)
                    else:
                        str = options + " splitted into: "
                        for option in options:
                            new_node = copy.deepcopy(node)
                            new_node.word = '-' + option
                            normalize_flag(new_node, attach_point)
                            str += new_node.word + ' '
                        if verbose:
                            print(str)

            head_cmd = attach_point.headcommand.value
            flag = node.word
            arg_type = man_lookup.get_flag_arg_type(head_cmd, flag)
            if arg_type:
                # flag is expecting an argument
                attach_point = attach_point.get_right_child()
                return (attach_point, ["argument"], [arg_type])
            else:
                # flag does not take arguments
                return attach_point_info

        def look_above(attach_point):
            head_cmd = attach_point.headcommand
            return (head_cmd, ["flags", "arguments"], None)

        # Attach point format: (pointer_to_the_attach_point,
        #                       ast_node_type, arg_type)
        attach_point_info = (current, ["headcommand"], [])

        ind = 0
        while ind < len(node.parts):
            attach_point = attach_point_info[0]
            possible_node_kinds = attach_point_info[1]
            possible_arg_types = attach_point_info[2]

            child = node.parts[ind]
            if child.kind == 'word':
                # prioritize processing of logic operators
                if is_unary_logic_op(child, attach_point):
                    norm_node = UnaryLogicOpNode(child.word)
                    attach_to_tree(norm_node, attach_point)
                    unary_logic_ops.append(norm_node)
                elif is_binary_logic_op(child, attach_point):
                    norm_node = BinaryLogicOpNode(child.word)
                    attach_to_tree(norm_node, attach_point)
                    binary_logic_ops.append(norm_node)
                else:
                    if child.word == "--" and not attach_point.is_command("awk"):
                        attach_point_info = (attach_point_info[0],
                                             ["argument"],
                                             attach_point_info[2])
                        ind += 1
                        continue

                    if len(possible_node_kinds) == 1:
                        # no ast_node_kind ambiguation
                        node_kind = possible_node_kinds[0]
                        if node_kind == "headcommand":
                            norm_node = normalize_headcommand(child,
                                                              attach_point)
                            head_commands.append(norm_node)
                            head_cmd = norm_node.value
                            arg_status = copy.deepcopy(man_lookup.get_arg_types(head_cmd))
                            attach_point_info = \
                                (norm_node, ["flag", "argument"], None)
                        elif node_kind == "argument":
                            if possible_arg_types and "Utility" in possible_arg_types:
                                # embedded command leaded by
                                # ["-exec", "-execdir", "-ok", "-okdir"]
                                new_command_node = bast.node(kind="command",
                                                             word="",
                                                             parts=[],
                                                             pos=(-1,-1))
                                new_command_node.parts = []
                                subcommand_added = False
                                for j in xrange(ind, len(node.parts)):
                                    if hasattr(node.parts[j], 'word') \
                                        and (node.parts[j].word == ";" \
                                        or node.parts[j].word == "+"):
                                        normalize_command(new_command_node,
                                                          attach_point)
                                        attach_point.value += \
                                            '::' + node.parts[j].word
                                        subcommand_added = True
                                        break
                                    else:
                                        new_command_node.parts.\
                                            append(node.parts[j])
                                if not subcommand_added:
                                    print("Warning: -exec missing ending ';'")
                                    normalize_command(new_command_node,
                                                      attach_point)
                                    attach_point.value += '::' + ";"
                                ind = j
                            else:
                                if possible_arg_types:
                                    arg_type = list(possible_arg_types)[0]
                                else:
                                    # "--" encountered
                                    arg_type = cmd_arg_type_check(child,
                                                                  arg_status)
                                # recurse to main normalization to handle
                                # argument with deep structures
                                normalize(child, attach_point, "argument",
                                          arg_type)
                            attach_point_info = look_above(attach_point)
                    else:
                        # need to decide ast_node_kind
                        if child.word.startswith("-") and \
                                not ((attach_point.value in ["head", "tail"]
                                      and child.word[1:].isdigit()) or
                                     (attach_point.value in ["chmod"]
                                      and ('r' in child.word or
                                           'x' in child.word or
                                           'w' in child.word or
                                           'X' in child.word or
                                           's' in child.word or
                                           't' in child.word or
                                           'u' in child.word or
                                           'g' in child.word or
                                           'o' in child.word))):
                            # child is a flag
                            attach_point_info = \
                                attach_flag(child, attach_point_info)
                        else:
                            # child is an argument
                            if expecting("Utility"):
                                # embedded command leaded by
                                # ["sh", "csh", "ksh", "tcsh",
                                #  "zsh", "bash", "exec", "xargs"]
                                new_command_node = bast.node(kind="command",
                                                             word="",
                                                             parts=[],
                                                             pos=(-1,-1))
                                new_command_node.parts = []
                                for j in xrange(ind, len(node.parts)):
                                    new_command_node.parts.append(node.parts[j])
                                normalize_command(new_command_node,
                                                  attach_point)
                                ind = j
                            else:
                                arg_type = cmd_arg_type_check(child.word, arg_status)
                                # recurse to main normalization to handle argument
                                # with deep structures
                                normalize(child, attach_point, "argument", arg_type)
                            attach_point_info = look_above(attach_point)

            elif child.kind == "assignment":
                normalize(child, attach_point, "assignment")
            elif child.kind == "redirect":
                normalize(child, attach_point, "redirect")

            ind += 1

        # TODO: some commands get parsed with no head command
        # This is usually due to unrecognized utilities e.g. "mp3player".
        if len(head_commands) == 0:
            return

        if len(head_commands) > 1:
            print("Error: multiple headcommands in one command.")
            for hc in head_commands:
                print(hc.symbol)
            sys.exit()

        head_command = head_commands[0]

        # process (embedded) parenthese -- treat as implicit "-and"
        stack = []
        depth = 0

        def pop_stack_content(depth, rparenth, stack_top=None):
            # popping pushed states off the stack
            popped = stack.pop()
            while (popped.value != "("):
                head_command.remove_child(popped)
                popped = stack.pop()
            lparenth = popped
            if not rparenth:
                # unbalanced brackets
                rparenth = ArgumentNode(value=")")
                make_parent_child(stack_top.parent, rparenth)
                make_sibling(stack_top, rparenth)
            new_child = organize_buffer(lparenth, rparenth)
            i = head_command.substitute_parentheses(lparenth, rparenth,
                                                    new_child)
            depth -= 1
            if depth > 0:
                # embedded parenthese
                stack.append(new_child)
            return depth, i

        i = 0
        while i < head_command.get_num_of_children():
            child = head_command.children[i]
            if child.value == "(":
                stack.append(child)
                depth += 1
            elif child.value == ")":
                assert(depth >= 0)
                # fix imbalanced parentheses: missing '('
                if depth == 0:
                    # simply drop the single ')'
                    detach_from_tree(child, child.parent)
                else:
                    depth, i = pop_stack_content(depth, child)
            else:
                if depth > 0:
                    stack.append(child)
                else:
                    if child.kind == "unarylogicop":
                        unprocessed_unary_logic_ops.append(child)
                    if child.kind == "binarylogicop":
                        unprocessed_binary_logic_ops.append(child)
            i += 1

        # fix imbalanced parentheses: missing ')'
        while (depth > 0):
            depth, _ = pop_stack_content(depth, None, stack[-1])

        assert(len(stack) == 0)
        assert(depth == 0)

        for ul in unprocessed_unary_logic_ops:
            adjust_unary_operators(ul)

        for bl in unprocessed_binary_logic_ops:
            adjust_binary_operators(bl)

        # process same options -- treat as implicit "-and"

        # recover omitted arguments
        if head_command.value == "find":
            arguments = []
            for child in head_command.children:
                if child.is_argument():
                    arguments.append(child)
            if head_command.get_num_of_children() > 0 and len(arguments) < 1:
                norm_node = ArgumentNode(value=".", arg_type="File")
                make_sibling(norm_node, head_command.children[0])
                norm_node.parent = head_command
                head_command.children.insert(0, norm_node)

        # "grep" normalization
        if head_command.value == "egrep":
            head_command.value = "grep"
            flag_present = False
            for child in head_command.children:
                if child.is_option() and child.value in ["-E", "--extended-regexp"]:
                    flag_present = True
            if not flag_present:
                norm_node = FlagNode(value="-E")
                make_sibling(norm_node, head_command.children[0])
                norm_node.parent = head_command
                head_command.children.insert(0, norm_node)

        if head_command.value == "fgrep":
            head_command.value = "grep"
            flag_present = False
            for child in head_command.children:
                if child.is_option() and child.value in ["-F", "--fixed-strings"]:
                    flag_present = True
            if not flag_present:
                norm_node = FlagNode(value="-F")
                make_sibling(norm_node, head_command.children[0])
                norm_node.parent = head_command
                head_command.children.insert(0, norm_node)

        # "xargs" normalization
        has_repl_str = False
        if head_command.value == "xargs":
            for flag in head_command.get_flags():
                if flag.value == "-I":
                    has_repl_str = True
                    repl_str = flag.get_argument()
                    assert(repl_str is not None)
                    if repl_str.value != "{}":
                        utility = head_command.get_subcommand()
                        assert(utility is not None)
                        utility.normalize_repl_str(repl_str.value, '{}')
                        repl_str.value = "{}"
                        repl_str.arg_type = "ReservedWord"
            # add a replace str if not present
            if not has_repl_str:
                utility = head_command.get_subcommand()
                assert(utility is not None)
                for i in xrange(head_command.get_num_of_children()):
                    if head_command.children[i].is_headcommand():
                        repl_str_flag_node = FlagNode("-I")
                        repl_str_node = ArgumentNode("{}", "ReservedWord")
                        repl_str_node2 = ArgumentNode("{}", "ReservedWord")
                        make_parent_child(repl_str_flag_node, repl_str_node)

                        head_command.children.insert(i, repl_str_flag_node)
                        repl_str_flag_node.parent = head_command
                        repl_str_flag_node.lsb = head_command.children[i-1]
                        head_command.children[i-1].rsb = repl_str_flag_node

                        repl_str_node2.parent = head_command
                        repl_str_node2.rsb = head_command.get_right_child()
                        head_command.children.append(repl_str_node2)
                        break


    def normalize(node, current, node_kind="", arg_type=""):
        # recursively normalize each subtree
        if not type(node) is bast.node:
            raise ValueError('type(node) is not ast.node')
        if node.kind == 'word':
            # assign fine-grained types
            if node.parts:
                # Compound arguments
                # commandsubstitution, processsubstitution, parameter
                if node.parts[0].kind == "processsubstitution":
                    if '>' in node.word:
                        norm_node = ProcessSubstitutionNode('>')
                        attach_to_tree(norm_node, current)
                        for child in node.parts:
                            normalize(child, norm_node)
                    elif '<' in node.word:
                        norm_node = ProcessSubstitutionNode('<')
                        attach_to_tree(norm_node, current)
                        for child in node.parts:
                            normalize(child, norm_node)
                elif node.parts[0].kind == "commandsubstitution":
                    norm_node = CommandSubstitutionNode()
                    attach_to_tree(norm_node, current)
                    for child in node.parts:
                        normalize(child, norm_node)
                elif node.parts[0].kind == "parameter" or \
                    node.parts[0].kind == "tilde":
                    normalize_argument(node, current, arg_type)
                else:
                    for child in node.parts:
                        normalize(child, current)
            else:
                normalize_argument(node, current, arg_type)
        elif node.kind == "pipeline":
            norm_node = PipelineNode()
            attach_to_tree(norm_node, current)
            if len(node.parts) % 2 == 0:
                print("Error: pipeline node must have odd number of parts")
                print(node)
                sys.exit()
            for child in node.parts:
                if child.kind == "command":
                    normalize(child, norm_node)
                elif child.kind == "pipe":
                    pass
                else:
                    raise ValueError(
                        "Error: unrecognized type of child of pipeline node")
        elif node.kind == "list":
            if len(node.parts) > 2:
                # multiple commands, not supported
                raise ValueError("Unsupported: list of length >= 2")
            else:
                normalize(node.parts[0], current)
        elif node.kind == "commandsubstitution" or \
             node.kind == "processsubstitution":
            normalize(node.command, current)
        elif node.kind == "command":
            try:
                normalize_command(node, current)
            except AssertionError, e:
                raise AssertionError("normalized_command AssertionError")
        elif hasattr(node, 'parts'):
            for child in node.parts:
                # skip current node
                normalize(child, current)
        elif node.kind == "redirect":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "operator":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "parameter":
            # not supported
            raise ValueError("Unsupported: parameters")
        elif node.kind == "compound":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "list":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "for":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "if":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "while":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "until":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "assignment":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "function":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "tilde":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "heredoc":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)

    try:
        cmd2 = cmd.encode('utf-8')
    except UnicodeDecodeError, e:
        cmd2 = cmd

    try:
        tree = bparser.parse(cmd)
    except tokenizer.MatchedPairError, e:
        print("Cannot parse: %s - MatchedPairError" % cmd2)
        # return basic_tokenizer(cmd, normalize_digits, False)
        return None
    except errors.ParsingError, e:
        print("Cannot parse: %s - ParsingError" % cmd2)
        # return basic_tokenizer(cmd, normalize_digits, False)
        return None
    except NotImplementedError, e:
        print("Cannot parse: %s - NotImplementedError" % cmd2)
        # return basic_tokenizer(cmd, normalize_digits, False)
        return None
    except IndexError, e:
        print("Cannot parse: %s - IndexError" % cmd2)
        # empty command
        return None
    except AttributeError, e:
        print("Cannot parse: %s - AttributeError" % cmd2)
        # not a bash command
        return None

    if len(tree) > 1:
        print("Doesn't support command with multiple root nodes: %s" % cmd2)
    normalized_tree = Node(kind="root")
    try:
        normalize(tree[0], normalized_tree)
    except ValueError as err:
        print("%s - %s" % (err.args[0], cmd2))
        return None
    except AttributeError as err:
        print("%s - %s" % (err.args[0], cmd2))
        return None
    except AssertionError as err:
        print("%s - %s" % (err.args[0], cmd2))
        return None

    return normalized_tree


def arg_slots(node):
    """Return argument slots of the ast."""
    slots = []

    def arg_slot_fun(node):
        if node.is_argument():
            slots.append([node.parent.value, node, False])
        else:
            for child in node.children:
                arg_slot_fun(child)

    arg_slot_fun(node)

    return [[node, taken] for _, node, taken in sorted(slots, key=lambda x:x[0])]


def prune_ast(node):
    """Return an ast without the argument nodes."""
    def prune_ast_fun(node):
        to_remove = []
        for child in node.children:
            if child.is_argument() and child.is_open_vocab():
                if child.lsb:
                    child.lsb.rsb = child.rsb
                if child.rsb:
                    child.rsb.lsb = child.lsb
                to_remove.append(child)
            else:
                prune_ast_fun(child)
        for child in to_remove:
            node.remove_child(child)

    if not node:
        return None
    node = copy.deepcopy(node)
    prune_ast_fun(node)

    return node


def order_ast(node):
    """Return an ast with sorted argument nodes."""
    def order_ast_fun(node):
        for child in node.chidren:
            pass
    if not node:
        return None
    node = copy.deepcopy(node)
    order_ast_fun(node)

    return node


def list_to_ast(list, order='dfs'):
    root = Node(kind="root", value="root")
    current = root
    if order == 'dfs':
        arg_status_stack = []
        for i in xrange(1, len(list)):
            if not current:
                break
            symbol = list[i]
            if symbol in [_V_NO_EXPAND, _H_NO_EXPAND]:
                if current and current.is_headcommand():
                    # print(current.value)
                    arg_status_stack.pop()
                current = current.parent
            else:
                kind, value = symbol.split('_', 1)
                kind = kind.lower()
                # add argument types
                if kind == "argument":
                    if current.is_option():
                        head_cmd = current.headcommand.value
                        flag = current.value
                        arg_type = \
                            man_lookup.get_flag_arg_type(head_cmd, flag)
                    elif current.is_headcommand():
                        arg_type = cmd_arg_type_check(
                            value, arg_status_stack[-1])
                    else:
                        print("Warning: to_ast unrecognized argument "
                              "attachment point {}.".format(current.symbol))
                        arg_type = "Unknown"
                    if value in ["+", ";", "{}"]:
                        arg_type = "ReservedWord"
                    node = ArgumentNode(value=value, arg_type=arg_type)
                elif kind == "flag":
                    node = FlagNode(value=value)
                elif kind == "headcommand":
                    node = HeadCommandNode(value=value)
                    arg_status = copy.deepcopy(
                            man_lookup.get_arg_types(value))
                    arg_status_stack.append(arg_status)
                elif kind == "unarylogicop":
                    node = UnaryLogicOpNode(value=value)
                else:
                    node = Node(kind=kind, value=value)
                attach_to_tree(node, current)
                current = node
    else:
        raise NotImplementedError
    return root


def to_tokens(node, loose_constraints=False, ignore_flag_order=False,
              arg_type_only=False, with_arg_type=False, with_parent=False):
    if not node:
        return []

    lc = loose_constraints
    ifo = ignore_flag_order
    ato = arg_type_only
    wat = with_arg_type
    wp = with_parent

    def to_tokens_fun(node):
        tokens = []
        if node.is_root():
            try:
                assert(loose_constraints or node.get_num_of_children() == 1)
            except AssertionError, e:
                return []
            if lc:
                for child in node.children:
                    tokens += to_tokens_fun(child)
            else:
                tokens = to_tokens_fun(node.children[0])
        elif node.kind == "pipeline":
            assert(loose_constraints or node.get_num_of_children() > 1)
            if lc and node.get_num_of_children() < 1:
                tokens.append("|")
            elif lc and node.get_num_of_children() == 1:
                # treat "single-pipe" as atomic command
                tokens += to_tokens_fun(node.children[0])
            else:
                for child in node.children[:-1]:
                    tokens += to_tokens_fun(child)
                    tokens.append("|")
                tokens += to_tokens_fun(node.children[-1])
        elif node.kind == "commandsubstitution":
            assert(loose_constraints or node.get_num_of_children() == 1)
            if lc and node.get_num_of_children() < 1:
                tokens += ["$(", ")"]
            else:
                tokens.append("$(")
                tokens += to_tokens_fun(node.children[0])
                tokens.append(")")
        elif node.kind == "processsubstitution":
            assert(loose_constraints or node.get_num_of_children() == 1)
            if lc and node.get_num_of_children() < 1:
                tokens.append(node.value + "(")
                tokens.append(")")
            else:
                tokens.append(node.value + "(")
                tokens += to_tokens_fun(node.children[0])
                tokens.append(")")
        elif node.is_headcommand():
            tokens.append(node.value)
            children = sorted(node.children, key=lambda x:x.value) \
                if ifo else node.children
            for child in children:
                tokens += to_tokens_fun(child)
        elif node.is_option():
            assert(loose_constraints or node.parent)
            if '::' in node.value:
                value, op = node.value.split('::')
                token = value
            else:
                token = node.value
            if wp:
                if node.parent:
                    token = node.headcommand.value + "@@" + token
                else:
                    token = "@@" + token
            tokens.append(token)
            for child in node.children:
                tokens += to_tokens_fun(child)
            if '::' in node.value:
                if op == ';':
                    op = "\\;"
                tokens.append(op)
        elif node.kind == "binarylogicop":
            assert(loose_constraints or node.get_num_of_children() > 1)
            if lc and node.get_num_of_children() < 2:
                for child in node.children:
                    tokens += to_tokens_fun(child)
            else:
                tokens.append("\\(")
                for i in xrange(len(node.children)-1):
                    tokens += to_tokens_fun(node.children[i])
                    tokens.append(node.value)
                tokens += to_tokens_fun(node.children[-1])
                tokens.append("\\)")
        elif node.kind == "unarylogicop":
            assert((loose_constraints or node.associate == UnaryLogicOpNode.LEFT)
                   or node.get_num_of_children() == 1)
            if lc and node.get_num_of_children() < 1:
                tokens.append(node.value)
            else:
                if node.associate == UnaryLogicOpNode.RIGHT:
                    tokens.append(node.value)
                    tokens += to_tokens_fun(node.children[0])
                else:
                    if node.get_num_of_children() > 0:
                        tokens += to_tokens_fun(node.children[0])
                    tokens.append(node.value)
        elif node.kind == "nt":
            assert(loose_constraints or node.get_num_of_children() > 0)
            if len(node.children) > 1 and node.children[0].value in ["and", "or"]:
                children = node.children[:1] + sorted(node.children[1:],
                                                      key=lambda x:x.value)
            else:
                children = node.children
            for child in children:
                tokens += to_tokens_fun(child)
        elif node.is_argument() or node.kind in ["t"]:
            assert(loose_constraints or node.get_num_of_children() == 0)
            if ato and node.is_open_vocab():
                token = node.arg_type
            else:
                token = node.value
            if wat:
                token = token + "_" + node.arg_type
            tokens.append(token)
            if lc:
                for child in node.children:
                    tokens += to_tokens_fun(child)
        return tokens

    return to_tokens_fun(node)


def test_tokenization():
    i_f = open(sys.argv[1])
    o_f = open(sys.argv[2], 'w')

    for cmd in i_f.readlines():
        cmd = cmd.strip()
        cmd = ' '.join(to_tokens(normalize_ast(cmd,
                            normalize_digits=False,
                            normalize_long_pattern=False)))
        # str = ''
        # for token in tokenizer.split(cmd):
        #     str += cmd + ' '
        o_f.write(cmd.strip() + '\n')


def test_normalize_pattern():
    value = sys.argv[1]
    print(normalize_pattern(value))


if __name__ == "__main__":
    test_normalize_pattern()

