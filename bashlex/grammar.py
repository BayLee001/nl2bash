#!/usr/bin/env python

"""
This file is adapted from /baselines/grammar/grammar.py & /baselines/grammar/enumerator.py.
It augments the AST generated by bashlex with single-command architecture and constraints.
"""

from __future__ import print_function
import collections
import json
import re
import ast, parser

_DIGIT_RE = re.compile(br"\d+")
_NUM = b"_NUM"

# TODO: add stdin & stdout types
simplified_bash_syntax = [
    "Command ::= SingleCommand | Pipe",
    "SingleCommand ::= HeadCommand [OptionList]",
    "OptionList ::= Option | OptionList",
    "Option ::= Flag [Argument] | LogicOp Option",
    "Argument ::= SingleArgument | CommandSubstitution | ProcessSubstitution",
    "Pipe ::= Command '|' Command",
    "CommandSubstitution ::= ` Command `",
    "ProcessSubstitution ::= <( Command ) | >( Command )"
]

arg_syntax = [
    "File",
    "Pattern",
    "Number",
    "NumberExp ::= -Number | +Number",
    "SizeExp ::= Number(k) | Number(M) | Number(G) | Number(T) | Number(P)",
    "TimeExp ::= Number(s) | Number(m) | Number(h) | Number(d) | Number(w)",
    # TODO: add fine-grained permission pattern
    "PermissionMode",
    "UserName",
    "GroupName",
    "Unknown"
]

class Node(object):
    def __init__(self, parent, lsb):
        """
        :member kind: ['pipe',
                      'headcommand',
                      'logicop',
                      'flag',
                      'file', 'pattern', 'numberexp',
                      'sizeexp', 'timeexp', 'permexp',
                      'username', 'groupname', 'unknown',
                      'number', 'unit', 'op',
                      'commandsubstitution',
                      'processsubstitution'
                     ]
        :member value: string value of the node
        :member children: list of child nodes
        """
        self.parent = parent
        self.lsb = lsb
        self.kind = ""
        self.value = ""
        self.children = []
        self.num_child = -1         # default value, permits arbitrary number of children
        self.children_types = []    # a list of allowed types for each child
                                    # a single-element list of allowed types for every child if self.num_child = -1
                                    # dummy field if self.num_child = 0

    def addChild(self, child):
        self.children.append(child)

# syntax constraints for different kinds of node
class HeadCommandNode(Node):
    def __init__(self, value, parent, lsb):
        super.__init__(parent, lsb)
        self.kind = 'headcommand'
        self.value = value
        self.children_types = [set('flag, logicop, argument')]

class FlagNode(Node):
    def __init__(self, value, parent, lsb, num_child, children_types):
        super.__init__(parent, lsb)
        self.kind = 'flag'
        self.value = value
        self.num_child = num_child
        self.children_types = children_types

class ArgumentNode(Node):
    def __init__(self, value, parent, lsb):
        super.__init__(parent, lsb)
        self.value = value
        self.num_child = 0

class FileNode(ArgumentNode):
    def __init__(self, value, parent, lsb):
        super.__init__(value, parent, lsb)
        self.kind = 'file'

# TODO: extend to model pattern structure
class PatternNode(ArgumentNode):
    def __init__(self, value, parent, lsb):
        super.__init__(value, parent, lsb)
        self.kind = 'pattern'

class NumberNode(ArgumentNode):
    def __init__(self, value, parent, lsb):
        super.__init__(value, parent, lsb)
        self.kind = 'number'

class TimeUnitNode(ArgumentNode):
    def __init__(self, value, parent, lsb):
        super.__init__(value, parent, lsb)
        self.kind = 'timeunit'

class SizeUnitNode(ArgumentNode):
    def __init__(self, value, parent, lsb):
        super.__init__(value, parent, lsb)
        self.kind = 'sizeunit'

class OpNode(ArgumentNode):
    def __init__(self, value, parent, lsb):
        super.__init__(value, parent, lsb)
        self.kind = 'op'

class LogicOpNode(ArgumentNode):
    def __init__(self, value, parent, lsb):
        super.__init__(value, parent, lsb)
        self.kind = 'logicop'
        self.num_child = 1
        self.children_types = [set('flag')]

class NumberExpNode(ArgumentNode):
    def __init__(self, value, parent, lsb):
        super.__init__(value, parent, lsb)
        self.kind = 'numberexp'
        self.num_child = 2
        self.children_types = [set('op'), set('number')]

class SizeExpNode(ArgumentNode):
    def __init__(self, value, parent, lsb):
        super.__init__(value, parent, lsb)
        self.kind = 'sizeexp'
        self.num_child = 2
        self.children_types = [set('number'), set('sizeunit')]

class TimeExpNode(ArgumentNode):
    def __init__(self, value, parent, lsb):
        super.__init__(value, parent, lsb)
        self.kind = 'timeexp'
        self.num_child = 2
        self.children_types = [set('number'), set('timeunit')]

# TODO: model permission pattern structure
class PermExpNode(ArgumentNode):
    def __init__(self, value, parent, lsb):
        super.__init__(value, parent, lsb)
        self.kind = 'permexp'

class UserNameNode(ArgumentNode):
    def __init__(self, value, parent, lsb):
        super.__init__(value, parent, lsb)
        self.kind = 'username'

class GroupNameNode(ArgumentNode):
    def __init__(self, value, parent, lsb):
        super.__init__(value, parent, lsb)
        self.kind = 'groupname'

class UnknownNode(ArgumentNode):
    def __init__(self, value, parent, lsb):
        super.__init__(value, parent, lsb)
        self.kind = 'unknown'

class PipeNode(Node):
    def __init__(self, parent, lsb):
        super.__init__(parent, lsb)
        self.kind = 'pipe'
        self.value = '|'
        self.num_child = 2
        self.children_types = [set(['pipe', 'headcommand']), set(['pipe', 'headcommand'])]

class CommandSubstitutionNode(Node):
    def __init__(self, parent, lsb):
        super.__init__(parent, lsb)
        self.kind = "commandsubstitution"
        self.value = ""
        self.num_child = 1
        self.children_types = [set('pipe', 'headcommand')]

class ProcessSubstitutionNode(Node):
    def __init__(self, parent, lsb):
        super.__init__(parent, lsb)
        self.kind = "processsubstitution"
        self.value = ""
        self.num_child = 1
        self.children_types = [set('pipe', 'headcommand')]

def pretty_print(node):
    pass

def linear_print(node):
    pass

def normalize_ast(cmd, normalize_digits):
    """
    Convert the bashlex parse tree of a command into the normalized form.
    :param cmd: bash command to parse
    :param normalize_digits: replace all digits in the tree with the special _NUM symbol
    :return net
    """

    tree = parser.parse(cmd)
    root = None




def load_syntax(json_files):
    simple_cmds = []
    counts = collections.defaultdict(int)
    for jsonfile in json_files:
        print("loading from {}".format(jsonfile))
        with open(jsonfile, "r") as f:
            syntax = json.loads(f.read())
        for cmd in syntax:
            simple_cmds.append(make_grammar_from_json_syntax(cmd))
            counts[cmd["name"]] += 1
            print(" --> loaded {} ({})".format(cmd["name"], counts[cmd["name"]]))
    return Node(Node.CASES, *simple_cmds)

def make_full_grammar(simple_grammar, max_pipeline_depth):
    pipe = Node(Node.EXACT, "|")
    def make_pipeline(g, n):
        return Node(Node.SEQ, g, *([Node(Node.SEQ, pipe, g)] * n))

    grammar = simple_grammar
    for n in range(max_pipeline_depth + 1):
        grammar = Node(Node.CASES, grammar, make_pipeline(simple_grammar, n))
    return grammar

def make_grammar_from_options(x, seen=None):
    if seen is None:
        seen = set()
    if x["type"] == "compound_options":
        return Node(Node.SEQ, *[make_grammar_from_options(o, seen=seen) for o in x["commands"]])
    elif x["type"] == "optional_option":
        flag_name = None
        if x["cmd"]["type"] == "flag_option":
            flag_name = x["cmd"]["flag_name"]
        elif x["cmd"]["type"] == "compound_options" and x["cmd"]["commands"][0]["type"] == "flag_option":
            flag_name = x["cmd"]["commands"][0]["flag_name"]
        if flag_name is not None and flag_name in seen:
            print("skipping duplicate flag -{}".format(flag_name), file=sys.stderr)
            return Node(Node.EMPTY)
        return Node(Node.CASES, Node(Node.EMPTY), make_grammar_from_options(x["cmd"], seen=seen))
    elif x["type"] == "exclusive_options":
        return Node(Node.CASES, *[make_grammar_from_options(o, seen=set(seen)) for o in x["commands"]])
    elif x["type"] == "flag_option":
        seen.add(x["flag_name"])
        g = Node(Node.EXACT, "-" + x["flag_name"])
    elif x["type"] == "long_flag_option":
        g = Node(Node.EXACT, "--" + x["flag_name"])
    elif x["type"] == "argument_option":
        return Node(Node.HOLE) # TODO: record type, description, etc...
    else:
        raise Exception("unknown type: {}".format(x["type"]))

    # has arg?
    if "arg_exists" in x and x["arg_exists"]:
        g = Node(Node.SEQ, g, make_grammar_from_options(x["argument"], seen=seen))
    return g

def make_grammar_from_json_syntax(syntax):
    g = Node(Node.EXACT, syntax["name"])
    g = Node(Node.SEQ, g, make_grammar_from_options(syntax["option"]))
    return g

class EnumeratorState(object):
    @staticmethod
    def from_grammar(grammar):
        if grammar.kind == Node.EMPTY:
            return EnumeratorState(Node.EMPTY)
        elif grammar.kind in [Node.CASES, Node.SEQ, Node.PERM]:
            return EnumeratorState(grammar.kind, [EnumeratorState.from_grammar(g) for g in grammar.args])
        elif grammar.kind == Node.EXACT:
            return EnumeratorState(Node.EXACT, tok=grammar.args[0])
        elif grammar.kind == Node.HOLE:
            return EnumeratorState(Node.HOLE)
        else:
            raise Exception("unknown kind {}".format(grammar.kind))

    def __init__(self, kind, sub_states=None, tok=None):
        self.kind = kind
        self.sub_states = sub_states or []
        self.tok = tok

    def __str__(self):
        if self.kind == Node.EMPTY:
            return "e"
        elif self.kind == Node.CASES:
            return "Cases({})".format(" | ".join(str(e) for e in self.sub_states))
        elif self.kind == Node.SEQ:
            return " ".join(str(e) for e in self.sub_states)
        elif self.kind == Node.PERM:
            return "Perm({})".format(", ".join(str(e) for e in self.sub_states))
        elif self.kind == Node.EXACT:
            return repr(self.tok)
        elif self.kind == Node.HOLE:
            return "_"

    # token -> EnumeratorState
    def push(self, token):
        assert token in self._legal_tokens(), "grammar {} cannot accept token {}".format(self, token)
        if self.kind == Node.EMPTY:
            return self
        elif self.kind == Node.CASES:
            return EnumeratorState(Node.CASES, [e.push(token) for e in self.sub_states if e.allows(token)])
        elif self.kind == Node.SEQ:
            i = 0
            new_state = None
            while True:
                if self.sub_states[i].allows(token):
                    new_state = self.sub_states[i].push(token)
                    break
                else:
                    assert self.sub_states[i].allow_eof()
                    i += 1
            if new_state:
                return EnumeratorState(Node.SEQ, [new_state] + self.sub_states[i+1:])
            else:
                return EnumeratorState(Node.EMPTY, [])
        elif self.kind == Node.PERM:
            pos = [e.push(token) for e in self.sub_states if e.allows(token)]
            neg = [e for e in self.sub_states if not e.allows(token)]
            assert len(pos) > 0
            e1 = pos[0] if len(pos) == 1 else EnumeratorState(Node.PERM, pos)
            e2 = EnumeratorState(Node.EMPTY) if len(neg) == 0 else neg[0] if len(neg) == 1 else EnumeratorState(Node.PERM, neg)
            return EnumeratorState(Node.SEQ, [e1, e2])
        elif self.kind == Node.EXACT:
            return EnumeratorState(Node.EMPTY) # consume this production
        elif self.kind == Node.HOLE:
            return EnumeratorState(Node.EMPTY) # consume this production
        else:
            raise Exception("unknown kind {}".format(self.kind))

    # query state
    def allow_eof(self):
        return self.allows(Enumerator.EOF)
    def allow_arbitrary(self):
        return self.allows(Enumerator.HOLE)
    def allows(self, token):
        return token in self._legal_tokens()
    def _legal_tokens(self):
        if self.kind == Node.EMPTY:
            yield Enumerator.EOF
        elif self.kind in [Node.CASES, Node.PERM]:
            for enum in self.sub_states:
                for tok in enum._legal_tokens():
                    yield tok
        elif self.kind == Node.SEQ:
            for enum in self.sub_states:
                eof = False
                for tok in enum._legal_tokens():
                    if tok == Enumerator.EOF:
                        eof = True
                    else:
                        yield tok
                if not eof:
                    break
            if eof:
                yield Enumerator.EOF
        elif self.kind == Node.EXACT:
            yield self.tok
        elif self.kind == Node.HOLE:
            yield Enumerator.HOLE
        else:
            raise Exception("unknown kind {}".format(self.kind))
    def legal_tokens(self):
        return set(self._legal_tokens())

class Enumerator(object):
    EOF = 0
    HOLE = 1

    def __init__(self, arg):
        if isinstance(arg, Node):
            self.state_stack = [EnumeratorState.from_grammar(arg)]
        elif isinstance(arg, list):
            self.state_stack = list(arg)
        else:
            raise Exception("cannot make enumerator of {}".format(arg))

    def __str__(self):
        return str(self.state_stack[-1])

    # alter state
    def push(self, token):
        self.state_stack.append(self.state_stack[-1].push(token))
    def pop(self):
        assert len(self.state_stack) > 1, "cannot pop() this enumerator"
        del self.state_stack[-1]
    def reset(self):
        self.state_stack = [self.state_stack[0]]

    # make a fresh copy of this enumerator
    def copy(self):
        return Enumerator(self.state_stack)

    # query state
    def allow_eof(self):
        return self.state_stack[-1].allow_eof()
    def allow_arbitrary(self):
        return self.state_stack[-1].allow_arbitrary()
    def allows(self, token):
        return self.state_stack[-1].allows(token)
    def legal_tokens(self):
        return self.state_stack[-1].legal_tokens()

if __name__ == "__main__":
    simple_grammar = load_syntax([os.path.join(os.path.dirname(__file__), "..", "data", "primitive_cmds_grammar_v1.json")])
    grammar = make_full_grammar(simple_grammar, max_pipeline_depth=3)

    e = Enumerator(grammar)
    while True:
        choices = list(e.legal_tokens())
        if Enumerator.HOLE in choices:
            choices.remove(Enumerator.HOLE)
            choices.append("*")
        if Enumerator.EOF in choices:
            choices.remove(Enumerator.EOF)
            choices.append("<EOF>")
        print("choices: {}".format(", ".join(choices)))
        try:
            inp = raw_input("> ")
            if inp == "$":
                print(e)
                continue
            if inp == "*":
                inp = Enumerator.HOLE
            e.push(inp)
        except EOFError as ex:
            break
    e.push(Enumerator.EOF)
