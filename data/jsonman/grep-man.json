{
	"aliases": ["grep", "egrep", "fgrep", "zgrep", "zegrep", "zfgrep"],
	"description": "file pattern searcher\n     The grep utility searches any given input files, selecting lines that\n     match one or more patterns.  By default, a pattern matches an input line\n     if the regular expression (RE) in the pattern matches the input line\n     without its trailing newline.  An empty expression matches every line.\n     Each input line that matches at least one of the patterns is written to\n     the standard output.\n\n     grep is used for simple patterns and basic regular expressions (BREs);\n     egrep can handle extended regular expressions (EREs).  See re_format(7)\n     for more information on regular expressions.  fgrep is quicker than both\n     grep and egrep, but can only handle fixed patterns (i.e. it does not\n     interpret regular expressions).  Patterns may consist of one or more\n     lines, allowing any of the pattern lines to match a portion of the input.\n\n     zgrep, zegrep, and zfgrep act like grep, egrep, and fgrep, respectively,\n     but accept input files compressed with the compress(1) or gzip(1) com-\n     pression utilities.",
	"optionLists": [{
		"type": "compound",
		"cmds": [{
			"type": "compound",
			"cmds": [{
				"type": "optional",
				"cmd": {
					"flagName": "a"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "b"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "c"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "d"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "D"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "E"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "F"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "G"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "H"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "h"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "I"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "i"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "J"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "L"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "l"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "m"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "n"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "O"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "o"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "p"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "q"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "R"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "S"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "s"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "U"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "V"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "v"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "w"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "x"
				}
			}, {
				"type": "optional",
				"cmd": {
					"flagName": "Z"
				}
			}]
		}, {
			"type": "optional",
			"cmd": {
				"type": "compound",
				"cmds": [{
					"flagName": "A"
				}, {
					"type": "argument",
					"argname": "num",
					"isList": false
				}]
			}
		}, {
			"type": "optional",
			"cmd": {
				"type": "compound",
				"cmds": [{
					"flagName": "B"
				}, {
					"type": "argument",
					"argname": "num",
					"isList": false
				}]
			}
		}, {
			"type": "optional",
			"cmd": {
				"type": "compound",
				"cmds": [{
					"flagName": "C"
				}, {
					"type": "optional",
					"cmd": {
						"type": "argument",
						"argname": "num",
						"isList": false
					}
				}]
			}
		}, {
			"type": "optional",
			"cmd": {
				"type": "compound",
				"cmds": [{
					"flagName": "e"
				}, {
					"type": "argument",
					"argname": "pattern",
					"isList": false
				}]
			}
		}, {
			"type": "optional",
			"cmd": {
				"type": "compound",
				"cmds": [{
					"flagName": "f"
				}, {
					"type": "argument",
					"argname": "file",
					"isList": false
				}]
			}
		}, {
			"type": "optional",
			"cmd": {
				"flagName": "binary-files"
			}
		}, {
			"type": "optional",
			"cmd": {
				"flagName": "color"
			}
		}, {
			"type": "optional",
			"cmd": {
				"flagName": "colour"
			}
		}, {
			"type": "optional",
			"cmd": {
				"flagName": "context"
			}
		}, {
			"type": "optional",
			"cmd": {
				"flagName": "label"
			}
		}, {
			"type": "optional",
			"cmd": {
				"flagName": "line-buffered"
			}
		}, {
			"type": "optional",
			"cmd": {
				"flagName": "null"
			}
		}, {
			"type": "optional",
			"cmd": {
				"type": "argument",
				"argname": "pattern",
				"isList": false
			}
		}, {
			"type": "optional",
			"cmd": {
				"type": "argument",
				"argname": "file",
				"isList": true
			}
		}]
	}],
	"optionDesc": [{
		"name": "  -A num",
		"option": {
			"type": "compound",
			"cmds": [{
				"flagName": "A"
			}, {
				"type": "argument",
				"argname": "num",
				"isList": false
			}]
		},
		"description": "\n     -A num, --after-context=num\n             Print num lines of trailing context after each match.  See also\n             the -B and -C options.\n"
	}, {
		"name": "-a",
		"option": {
			"flagName": "a"
		},
		"description": "\n     -a, --text\n             Treat all files as ASCII text.  Normally grep will simply print\n             ``Binary file ... matches'' if files contain binary characters.\n             Use of this option forces grep to output lines matching the spec-\n             ified pattern.\n"
	}, {
		"name": "  -B num",
		"option": {
			"type": "compound",
			"cmds": [{
				"flagName": "B"
			}, {
				"type": "argument",
				"argname": "num",
				"isList": false
			}]
		},
		"description": "\n     -B num, --before-context=num\n             Print num lines of leading context before each match.  See also\n             the -A and -C options.\n"
	}, {
		"name": "-b",
		"option": {
			"flagName": "b"
		},
		"description": "\n     -b, --byte-offset\n             The offset in bytes of a matched pattern is displayed in front of\n             the respective matched line.\n"
	}, {
		"name": "-c",
		"option": {
			"flagName": "c"
		},
		"description": "\n     -c, --count\n             Only a count of selected lines is written to standard output.\n"
	}, {
		"name": "  -D action",
		"option": {
			"type": "compound",
			"cmds": [{
				"flagName": "D"
			}, {
				"type": "argument",
				"argname": "action",
				"isList": false
			}]
		},
		"description": "\n     -D action, --devices=action\n             Specify the demanded action for devices, FIFOs and sockets.  The\n             default action is `read', which means, that they are read as if\n             they were normal files.  If the action is set to `skip', devices\n             will be silently skipped.\n"
	}, {
		"name": "  -d action",
		"option": {
			"type": "compound",
			"cmds": [{
				"flagName": "d"
			}, {
				"type": "argument",
				"argname": "action",
				"isList": false
			}]
		},
		"description": "\n     -d action, --directories=action\n             Specify the demanded action for directories.  It is `read' by\n             default, which means that the directories are read in the same\n             manner as normal files.  Other possible values are `skip' to\n             silently ignore the directories, and `recurse' to read them\n             recursively, which has the same effect as the -R and -r option.\n"
	}, {
		"name": "-E",
		"option": {
			"flagName": "E"
		},
		"description": "\n     -E, --extended-regexp\n             Interpret pattern as an extended regular expression (i.e. force\n             grep to behave as egrep).\n"
	}, {
		"name": "  -e pattern",
		"option": {
			"type": "compound",
			"cmds": [{
				"flagName": "e"
			}, {
				"type": "argument",
				"argname": "pattern",
				"isList": false
			}]
		},
		"description": "\n     -e pattern, --regexp=pattern\n             Specify a pattern used during the search of the input: an input\n             line is selected if it matches any of the specified patterns.\n             This option is most useful when multiple -e options are used to\n             specify multiple patterns, or when a pattern begins with a dash\n             (`-').\n"
	}, {
		"name": "--exclude",
		"option": {
			"flagName": "exclude"
		},
		"description": "\n     --exclude\n             If specified, it excludes files matching the given filename pat-\n             tern from the search.  Note that --exclude patterns take priority\n             over --include patterns, and if no --include pattern is speci-\n             fied, all files are searched that are not excluded.  Patterns are\n             matched to the full path specified, not only to the filename com-\n             ponent.\n"
	}, {
		"name": "--exclude-dir",
		"option": {
			"flagName": "exclude-dir"
		},
		"description": "\n     --exclude-dir\n             If -R is specified, it excludes directories matching the given\n             filename pattern from the search.  Note that --exclude-dir pat-\n             terns take priority over --include-dir patterns, and if no\n             --include-dir pattern is specified, all directories are searched\n             that are not excluded.\n"
	}, {
		"name": "-F",
		"option": {
			"flagName": "F"
		},
		"description": "\n     -F, --fixed-strings\n             Interpret pattern as a set of fixed strings (i.e. force grep to\n             behave as fgrep).\n"
	}, {
		"name": "  -f file",
		"option": {
			"type": "compound",
			"cmds": [{
				"flagName": "f"
			}, {
				"type": "argument",
				"argname": "file",
				"isList": false
			}]
		},
		"description": "\n     -f file, --file=file\n             Read one or more newline separated patterns from file.  Empty\n             pattern lines match every input line.  Newlines are not consid-\n             ered part of a pattern.  If file is empty, nothing is matched.\n"
	}, {
		"name": "-G",
		"option": {
			"flagName": "G"
		},
		"description": "\n     -G, --basic-regexp\n             Interpret pattern as a basic regular expression (i.e. force grep\n             to behave as traditional grep).\n"
	}, {
		"name": "-H",
		"option": {
			"flagName": "H"
		},
		"description": "\n     -H      Always print filename headers with output lines.\n"
	}, {
		"name": "-h",
		"option": {
			"flagName": "h"
		},
		"description": "\n     -h, --no-filename\n             Never print filename headers (i.e. filenames) with output lines.\n"
	}, {
		"name": "--help",
		"option": {
			"flagName": "help"
		},
		"description": "\n     --help  Print a brief help message.\n"
	}, {
		"name": "-I",
		"option": {
			"flagName": "I"
		},
		"description": "\n     -I      Ignore binary files.  This option is equivalent to\n             --binary-file=without-match option.\n"
	}, {
		"name": "-i",
		"option": {
			"flagName": "i"
		},
		"description": "\n     -i, --ignore-case\n             Perform case insensitive matching.  By default, grep is case sen-\n             sitive.\n"
	}, {
		"name": "--include",
		"option": {
			"flagName": "include"
		},
		"description": "\n     --include\n             If specified, only files matching the given filename pattern are\n             searched.  Note that --exclude patterns take priority over\n             --include patterns.  Patterns are matched to the full path speci-\n             fied, not only to the filename component.\n"
	}, {
		"name": "--include-dir",
		"option": {
			"flagName": "include-dir"
		},
		"description": "\n     --include-dir\n             If -R is specified, only directories matching the given filename\n             pattern are searched.  Note that --exclude-dir patterns take pri-\n             ority over --include-dir patterns.\n"
	}, {
		"name": "-J",
		"option": {
			"flagName": "J"
		},
		"description": "\n     -J, --bz2decompress\n             Decompress the bzip2(1) compressed file before looking for the\n             text.\n"
	}, {
		"name": "-L",
		"option": {
			"flagName": "L"
		},
		"description": "\n     -L, --files-without-match\n             Only the names of files not containing selected lines are written\n             to standard output.  Pathnames are listed once per file searched.\n             If the standard input is searched, the string ``(standard\n             input)'' is written.\n"
	}, {
		"name": "-l",
		"option": {
			"flagName": "l"
		},
		"description": "\n     -l, --files-with-matches\n             Only the names of files containing selected lines are written to\n             standard output.  grep will only search a file until a match has\n             been found, making searches potentially less expensive.  Path-\n             names are listed once per file searched.  If the standard input\n             is searched, the string ``(standard input)'' is written.\n"
	}, {
		"name": "--mmap",
		"option": {
			"flagName": "mmap"
		},
		"description": "\n     --mmap  Use mmap(2) instead of read(2) to read input, which can result in\n             better performance under some circumstances but can cause unde-\n             fined behaviour.\n"
	}, {
		"name": "  -m num",
		"option": {
			"type": "compound",
			"cmds": [{
				"flagName": "m"
			}, {
				"type": "argument",
				"argname": "num",
				"isList": false
			}]
		},
		"description": "\n     -m num, --max-count=num\n             Stop reading the file after num matches.\n"
	}, {
		"name": "-n",
		"option": {
			"flagName": "n"
		},
		"description": "\n     -n, --line-number\n             Each output line is preceded by its relative line number in the\n             file, starting at line 1.  The line number counter is reset for\n             each file processed.  This option is ignored if -c, -L, -l, or -q\n             is specified.\n"
	}, {
		"name": "--null",
		"option": {
			"flagName": "null"
		},
		"description": "\n     --null  Prints a zero-byte after the file name.\n"
	}, {
		"name": "-O",
		"option": {
			"flagName": "O"
		},
		"description": "\n     -O      If -R is specified, follow symbolic links only if they were\n             explicitly listed on the command line.  The default is not to\n             follow symbolic links.\n"
	}, {
		"name": "-o",
		"option": {
			"flagName": "o"
		},
		"description": "\n     -o, --only-matching\n             Prints only the matching part of the lines.\n"
	}, {
		"name": "-p",
		"option": {
			"flagName": "p"
		},
		"description": "\n     -p      If -R is specified, no symbolic links are followed.  This is the\n             default.\n"
	}, {
		"name": "-q",
		"option": {
			"flagName": "q"
		},
		"description": "\n     -q, --quiet, --silent\n             Quiet mode: suppress normal output.  grep will only search a file\n             until a match has been found, making searches potentially less\n             expensive.\n"
	}, {
		"name": "-q",
		"option": {
			"flagName": "q"
		},
		"description": "\n     -q, --quiet, --silent\n             Quiet mode: suppress normal output.  grep will only search a file\n             until a match has been found, making searches potentially less\n             expensive.\n"
	}, {
		"name": "-R",
		"option": {
			"flagName": "R"
		},
		"description": "\n     -R, -r, --recursive\n             Recursively search subdirectories listed.\n"
	}, {
		"name": "-R",
		"option": {
			"flagName": "R"
		},
		"description": "\n     -R, -r, --recursive\n             Recursively search subdirectories listed.\n"
	}, {
		"name": "-S",
		"option": {
			"flagName": "S"
		},
		"description": "\n     -S      If -R is specified, all symbolic links are followed.  The default\n             is not to follow symbolic links.\n"
	}, {
		"name": "-s",
		"option": {
			"flagName": "s"
		},
		"description": "\n     -s, --no-messages\n             Silent mode.  Nonexistent and unreadable files are ignored (i.e.\n             their error messages are suppressed).\n"
	}, {
		"name": "-U",
		"option": {
			"flagName": "U"
		},
		"description": "\n     -U, --binary\n             Search binary files, but do not attempt to print them.\n"
	}, {
		"name": "-V",
		"option": {
			"flagName": "V"
		},
		"description": "\n     -V, --version\n             Display version information and exit.\n"
	}, {
		"name": "-v",
		"option": {
			"flagName": "v"
		},
		"description": "\n     -v, --invert-match\n             Selected lines are those not matching any of the specified pat-\n             terns.\n"
	}, {
		"name": "-w",
		"option": {
			"flagName": "w"
		},
		"description": "\n     -w, --word-regexp\n             The expression is searched for as a word (as if surrounded by\n             `[[:<:]]' and `[[:>:]]'; see re_format(7)).\n"
	}, {
		"name": "-x",
		"option": {
			"flagName": "x"
		},
		"description": "\n     -x, --line-regexp\n             Only input lines selected against an entire fixed string or regu-\n             lar expression are considered to be matching lines.\n"
	}, {
		"name": "-y",
		"option": {
			"flagName": "y"
		},
		"description": "\n     -y      Equivalent to -i.  Obsoleted.\n"
	}, {
		"name": "-Z",
		"option": {
			"flagName": "Z"
		},
		"description": "\n     -Z, -z, --decompress\n             Force grep to behave as zgrep.\n"
	}, {
		"name": "-Z",
		"option": {
			"flagName": "Z"
		},
		"description": "\n     -Z, -z, --decompress\n             Force grep to behave as zgrep.\n"
	}, {
		"name": "--binary-files=value",
		"option": {
			"flagName": "binary-files"
		},
		"description": "\n     --binary-files=value\n             Controls searching and printing of binary files.  Options are\n             binary, the default: search binary files but do not print them;\n             without-match: do not search binary files; and text: treat all\n             files as text.\n"
	}, {
		"name": "--context[=num]",
		"option": {
			"flagName": "context"
		},
		"description": "\n     --context[=num]\n             Print num lines of leading and trailing context.  The default is\n             2.\n"
	}, {
		"name": "--line-buffered",
		"option": {
			"flagName": "line-buffered"
		},
		"description": "\n     --line-buffered\n             Force output to be line buffered.  By default, output is line\n             buffered when standard output is a terminal and block buffered\n             otherwise.\n"
	}],
	"name": "grep"
}